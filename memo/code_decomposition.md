## 문제의 크기

프로그래머가 한 번에 다룰 수 있는 문제의 크기는 한계를 가진다
-> 어떤 기준에서든지, 도구의 도움을 받아서 더 작은 단위로 문제를 나누어서 해결한다.

프로그래머는 더 큰 문제를 자주 마주한다

시스템의 크기는 점점 커짐

큰 문제는 작은 문제로 분해할 수 있음

작은 문제의 일부는 반복됨
-> 내부의 코드베이스, 혹은 외부에서 제공된 방법으로 해결할 수 있는 경우가 있다.

코드를 읽는 작업은 코드를 쓰는 작업에 굉장히 많은 비중을 차지한다.

코드를 쓰는 작업과 읽는 작업은 서로 독립된 과정이 아니다. 서로 굉장히 밀접한 관계를 맺는다.

기존에 작성된 일부 코드와 협력해서 유기적으로 작동하는 코드를 작성해야 하기 때문에
기존 코드를 읽는 작업의 비용이 높을 수 밖에 없다.

## 코드 재사용

반복되는 문제의 풀이는 재사용 가능

커다란 문제는 작은 문제로 나눌 수 있고, 계속 반복되는 문제의 해법은 재사용할 수 있다.

-> 재사용된 코드 조각을 사용할 때의 원칙은 이전에 작성된 코드를 전혀 수정하지 않고 사용하는 것이다.(중요한 점이다)
어떤 의도를 가지고 코드를 수정을 할텐데, 코드의 변경은 해당 코드와 연결되어 있는 코드에 어떤 영향을 미칠 지 예측하기가 힘들다.
재사용하려는 코드에 의도하지 않은, 의도를 벗어난 어떤 효과가 발생할 지 예측하기가 힘들다.

작성된 코드를 패키지로 만들어서 사용하는 방식 -> 라이브러러
시스템을 만드는 팀에서 만들거나 오픈 소스/라이브러리 벤더를 통해서 제공받을 수도 있다.

코드를 재사용하는 것은 
이런 반복되는 해법 없이 코드를 새로 작성해서만 문제를 해결하게 되면 비용이 높다.
-> 당연히 비용절감 효과가 있다.

문제를 나눌 수 있는 것처럼 해법도 나눌 수 있다.

## 모듈화 

분해 

- 큰 시스템은 더 작은 하위 시스템으로 분해가 가능하다.
- 교체 가능

조립 - 분해된 작은 시스템들

- 작은 시스템은 더 큰 상위 시스템으로 조립 가능
- 모듈 재사용
- 라이브러리

분해된 작은 시스템들(모듈)은 크게 두 가지로 구성된다.

인터페이스 - 모듈이 어떤 기능을 제공하는지, 그 기능을 사용하기 위해서는 어떻게 이 모듈을 사용해야 하는지에 대한 설계
구현 - 그 기능이 실제로 어떻게 만들어 지는지

이미 만들어진 모듈을 사용하여 상위 시스템을 만들 때에는 구현이 아니라 인터페이스를 고려해서 사용을 한다.
내가 기존에 존재하는 코드를 어디에 배치해서 어떻게 사용해야 할지를 고려해서 설계를 하는 것이지 
모든 요구 사항들을 내부적으로 어떻게 구현할지를 고려하고 상위 시스템을 만들지는 않는다. 

모듈이 인터페이스와 구현이 잘 구분되어 있고, 인터페이스 부분이 잘 정제되어 있다면, 풀어야 할 문제, 해법들에 대해서 전체를 다 고려하지 않고 필요한 부분만 고려해서 새로운, 더 큰 문제를 해결할 수 있게 된다

재사용하기 쉽게 만들어진 모듈들은 코드를 읽는 비용을 감소시키기도 한다.
(엔지니어링은 진리의 영역이 아니다. 상황과 사람에 따라서 다를 수도 있다.)
모듈이 인터페이스와 구현으로 잘 구분되어 있고, 인터페이스가 모듈이 지원하는 기능을 잘 표현하고 있다면
사용하는 입장에서 가능하면 실수를 줄이도록 인터페이스가 잘 설계되어 있다면, 
이 모듈을 사용하는 데 필요한 정보가 줄어들고 모듈이 제공해주는 코드를 읽고 이 코드를 조합하고 설계하는 데 드는 비용이 줄어든다.

이 모듈들이 아무리 인터페이스들이 잘 정제되어 있고, 구현이 잘 숨어있다고 하더라도 
충분히 모듈을 신뢰할 수 있어야 해당 모듈을 마음대로 사용할 수 있다.
따라서 모듈을 만드는 쪽에서 모듈을 잘 테스트해서 사용자에게 제공해주어야 한다.
이 때 대부분의 경우에는 수동으로 모듈들을 테스트하지 않고 자동화된 테스트를 사용한다. -> 이 경우 단위 테스트를 사용하게 된다.
사용자는 충분히 단위 테스트된 모듈을 신뢰하고 사용할 수 있게 된다.

